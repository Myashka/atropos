<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rendered Messages - llm_judge_sigmarule_1.jsonl</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; margin: 20px; }
        details { border: 1px solid #ccc; border-radius: 4px; margin-bottom: 15px; }
        summary {
            font-weight: bold;
            padding: 10px;
            background-color: #f0f0f0;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            border-bottom: 1px solid #ccc;
            outline: none; /* Remove default focus outline if needed */
        }
        details[open] summary { border-bottom: 1px solid #ccc; }
        .group-content { padding: 15px; }
        .item {
            border: 1px solid #eee;
            border-radius: 3px;
            margin-bottom: 10px;
            padding: 10px;
            transition: background-color 0.3s ease, box-shadow 0.2s ease; /* Smooth transitions */
            scroll-margin-top: 10px; /* Space when scrolling into view */
        }
        .item h4 { margin-top: 0; margin-bottom: 5px; font-size: 1.1em; }
        .content-block { background-color: #fff; padding: 8px; border-radius: 3px; margin-bottom: 5px; overflow-x: auto; }
        /* Use :focus-within for better accessibility on container focus */
        .item:focus, .item.active {
             box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5); /* Highlight active/focused item */
             outline: none; /* Remove default outline */
        }

        /* Score Backgrounds (Faint) */
        .reward-positive { background-color: rgba(144, 238, 144, 0.3); } /* Faint light green */
        .reward-zero { background-color: rgba(255, 215, 0, 0.3); }    /* Faint gold/orange */
        .reward-negative { background-color: rgba(255, 182, 193, 0.4); } /* Faint light pink/red */

        /* Markdown specific styles */
        .content-block pre {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 10px;
            overflow-x: auto; /* Allow horizontal scrolling for long code lines */
            white-space: pre-wrap; /* Wrap long lines within pre */
            word-wrap: break-word; /* Break long words if necessary */
        }
        .content-block code {
             background-color: #f0f0f0; /* Slightly different for inline code */
             padding: 0.2em 0.4em;
             border-radius: 3px;
             font-size: 0.9em;
        }
        .content-block pre code {
            background-color: transparent; /* Don't double-background code in pre blocks */
            padding: 0;
            border-radius: 0;
            font-size: inherit; /* Inherit pre font size */
        }
        .content-block blockquote {
            border-left: 4px solid #ccc;
            padding-left: 10px;
            margin-left: 0;
            color: #555;
        }
        .content-block table {
            border-collapse: collapse;
            width: auto; /* Don't force full width */
            margin-bottom: 1em;
        }
        .content-block th, .content-block td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .content-block th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>Rendered Messages - llm_judge_sigmarule_1.jsonl</h1>
    <div id="groups-container">
                <details>
            <summary>Group 0</summary>
            <div class="group-content">
                            <div class="item reward-zero" id="group-0-item-0">
                <h4>Content 0</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule for detecting when a DLL file is loaded by an Office application. Let me start by thinking about what logs I would look for. Typically, Office applications log events when DLLs are loaded, especially if they're not expected. </p>
<p>The key fields I need to capture are:<br />
- The process name (like Excel.exe, Word.exe, etc.)<br />
- The DLL file that was loaded<br />
- The load time<br />
- The user who initiated the load</p>
<p>I should set the logsource category to application or process. The condition would check for the DLL name in the event. Since this is a persistence technique, maybe using a count over time would help, but the initial rule just needs to detect any occurrence.</p>
<p>I'll use the detection.condition to check for the DLL name in the log entry. The selection might be looking for specific keywords like "assembly loaded" or the DLL name. The timeframe should be short, like 1 hour, to catch recent activities.</p>
<p>Wait, what's the exact field name for the process name in different logs? It might vary. I should use the common ones like process_name or parent_process. Also, the action in the selection would be the event describing the DLL load.</p>
<p>Putting this all together, the rule should trigger whenever an Office process loads an unexpected DLL. The indicators are the process name matching an Office app and the DLL name being loaded. The logsource category needs to be process or application. I'll include the timeframe and make sure the detection.condition properly matches the DLL name.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection where process_name in ('excel.exe', 'word.exe', 'powerpnt.exe', 'outlook.exe') and dll_name matches '/.*.dll$/'<br />
  selection: event.type == "dll_loaded"<br />
  timeframe: 1h<br />
logsource:<br />
  category: process<br />
  product: windows<br />
references:<br />
  - https://attack.mitre.org/techniques/T1055/001/<br />
tags:<br />
  - attack.t1055.001<br />
  - defense_evasion<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-0-item-1">
                <h4>Content 1</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule that detects when a.NET assembly DLL is loaded via an Office application. Let's break this down.</p>
<p>First, the key points: the event should involve an Office application (like Word, Excel) loading a.NET assembly DLL. So the log source would probably be the Office application's logging or the Windows Event Log.</p>
<p>The event type in Windows Event Log that tracks DLL loading is the "Process Creation" event. That's event ID 1. So I should look for that event ID.</p>
<p>Then, the product name should be an Office application, like Microsoft Office Word, Microsoft Excel, etc. The product name is usually part of the event details.</p>
<p>The image name would be the process executing the DLL load. Since it's Office, it might be something like winword.exe or excel.exe. But I should check if the process name matches known Office process names.</p>
<p>The command line parameters might include a reference to the DLL being loaded. The assembly DLL would be a.NET file, maybe with a.dll extension and a.NET framework name like System.Windows.Forms.dll or something like that.</p>
<p>The user account under which the process runs could be important. Maybe a standard user account versus an admin account?</p>
<p>The process creation time would need a timeframe, perhaps 24 hours.</p>
<p>So putting this all together, the fields would be:</p>
<ul>
<li>EventCode: 1</li>
<li>EventID: 1</li>
<li>LogSource: Windows Event Log</li>
<li>UserID (if available)</li>
<li>Product: Microsoft Office application name</li>
<li>Image: Office process name</li>
<li>CommandLine: containing the path to the DLL</li>
<li>DLLName: the.NET assembly DLL</li>
</ul>
<p>I should check the Windows Event Log schema for these fields. In Sigma, the exact field names might differ. For example, in Windows Event Log, the product name is referred to as "Product" and the image name as "Image".</p>
<p>The detection condition would be when the DLL name contains a.NET assembly and is loaded by an Office process.</p>
<p>So the Sigma rule would look something like:</p>
<p>```<br />
detection:<br />
  condition: selection where (CommandLine contains ".dll") and Product contains "Microsoft Office"</p>
<p>selection:<br />
  EventCode: 1<br />
  Product: "Microsoft Office Word"<br />
  Image: "winword.exe"<br />
  CommandLine: /do<br />
  User: "Office User"<br />
  DLLName: "System.Windows.Forms.dll"<br />
  UserID: "S-1-5-21-1234567890-1234567890-1234567890-1234"</p>
<p>logsource:<br />
  category: process_creation<br />
  product: windows<br />
</pre></p>
<p>Wait, but the Office application could vary. Maybe using a generic Office product name like "Microsoft Office" to catch any of them.</p>
<p>Also, the DLL name might be anything, not just System.Windows.Forms.dll. So the condition should check that the command line contains ".dll" and the product is an Office app.</p>
<p>The UserID might not always be present, so maybe not including it. Alternatively, if it's available, include it.</p>
<p>Putting this all together, the final YAML would have:</p>
<ul>
<li>Logsource: Windows, category process_creation</li>
<li>Detection condition: command line contains ".dll" and product contains "Microsoft Office"</li>
<li>Selection: EventCode 1, Product contains "Microsoft Office", Image contains Office process name, CommandLine contains.dll</li>
<li>Timeframe: 24h</li>
</ul>
<p>I need to make sure the fields are correctly named according to Sigma standards, like EventCode, not EventID. Also, using the correct field names like Product and Image.</p>
<p>The exact fields might vary based on the Windows Event Log schema. Let me verify:</p>
<p>In the Windows Event Log schema, the fields are:</p>
<ul>
<li>EventCode (EventCode)</li>
<li>EventID</li>
<li>UserID</li>
<li>Product (Product)</li>
<li>Image (Image)</li>
<li>CommandLine</li>
<li>DLL</li>
<li>etc.</li>
</ul>
<p>So the fields in Sigma would correspond to these.</p>
<p>Therefore, the final Sigma rule should have:</p>
<ul>
<li>detection.condition: selection where CommandLine contains ".dll" and Product contains "Microsoft Office"</li>
<li>selection: fields matching the criteria</li>
<li>logsource: category process_creation, product windows<br />
</think></li>
</ul>
<p>\boxed{<br />
detection:<br />
  condition: selection and CommandLine contains ".dll" and Product contains "Microsoft Office"<br />
  selection:<br />
    EventCode: 1<br />
    Product: "Microsoft Office"<br />
    Image: "winword.exe|excel.exe|powerpnt.exe|msaccess.exe|onenote.exe|outlook.exe"<br />
    CommandLine: "<em>"<br />
    DLL: "</em>"<br />
logsource:<br />
  category: process_creation<br />
  product: windows<br />
timeframe: 24h<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-0-item-2">
                <h4>Content 2</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule to detect when a DLL assembly is loaded by an Office application. Let's start by understanding what the key components of this scenario are.</p>
<p>First, the main action here is the loading of a DLL assembly. So I need to think about the specific event that gets logged when an assembly is loaded. In Windows, there are Event ID 26 events in the Application log that are generated when an assembly is loaded. This event is triggered by the CLR (Common Language Runtime) when a managed assembly is loaded.</p>
<p>Next, the context is that this assembly is being loaded via an Office application. So the Office application is the process that is loading the DLL. I need to determine how to capture the process name of the Office application. Some common Office applications are Word, Excel, PowerPoint, etc. But I should use a generic approach so it covers all Office products.</p>
<p>The log source should be the Windows Application log, specifically looking for Event ID 26, which is related to assembly loading. The condition would then be that the Event ID is 26 and the process name contains an Office application.</p>
<p>I should check the logsource category and product fields. The category could be set to 'Windows' or 'Application', depending on the Sigma specification. The product should be 'CLR' or similar. The event ID is 26.</p>
<p>For the detection condition, the key elements are event ID 26 and the process name containing a known Office product. The selection would be the event where (EventID = 26) and (process.name contains 'excel|word|powerpoint|...').</p>
<p>I should also include a timeframe of 24 hours to look for recent activity. The action should be set to 'denied' or 'loaded' but since this is a detection rule, maybe the action is just the occurrence of the event.</p>
<p>So putting it all together, the Sigma rule will look for Windows Application log events (EventID 26) where the process name includes any Office application, indicating an assembly was loaded via an Office product.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  selection:<br />
    event.id: 26<br />
    process.name: "<em>excel.exe|</em>word.exe|<em>powerpnt.exe|</em>onenote.exe|<em>ppt.exe|</em>visio.exe|<em>project.exe|</em>access.exe|*publisher.exe"<br />
  condition: selection<br />
logsource:<br />
  category: windows<br />
  product: windows<br />
timeframe: 24h<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-0-item-3">
                <h4>Content 3</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, so I need to create a Sigma rule for detecting when a DLL is loaded via an Office application. Let me think through this step by step.</p>
<p>First, what's the typical scenario here? Office products like Word or Excel can load external DLLs. This is often used for malicious purposes, like loading a malicious DLL to execute code. So the key thing is detecting when an Office app loads a DLL.</p>
<p>Now, how are these events logged? I'm not exactly sure which Windows Event Log this information is recorded in. Maybe the Application log? Or perhaps the Windows Security log? I need to check that.</p>
<p>Assuming the events are logged in the Application log, the LogSource category would be Application. But I need to confirm that. Alternatively, maybe the Windows Security log has specific entries for DLL loading. I should think about how DLL loading is typically monitored. Maybe the event ID is something like 4688 from Windows Audit Process Creation, but that's part of the Windows Security log. Hmm.</p>
<p>Wait, the question specifically mentions Office applications. So perhaps when an Office app loads a DLL, it creates a process, and that process creation would be logged in the Security log. So the LogSource category would be Windows Security. But I'm not certain. I'll need to check common event IDs related to DLL loading in Office.</p>
<p>Another angle: sometimes Office apps have specific logging for such activities. For example, Microsoft Office might log events in its own application log when a plugin or add-in is loaded. But I'm not sure about the exact event IDs or event types.</p>
<p>Alternatively, maybe the DLL loading is detected via Windows Defender or other security tools. But the user is asking for a generic Sigma rule, so probably using built-in Windows logging.</p>
<p>Let me think about the fields. The main ones would be:<br />
- Event ID<br />
- Logsource category and product<br />
- Data that indicates the DLL being loaded<br />
- Source process (the Office application)<br />
- Action or operation type</p>
<p>So for example, if the event ID is 4688 in the Windows Security log, and the event includes details about a new process being created, which is an Office app loading a DLL. The condition would look for the DLL path in the process command line or related fields.</p>
<p>Alternatively, if it's an application log event, perhaps a specific event ID when an Office app loads an add-in. Let me check my knowledge. For example, when Office loads an add-in, it might create a process for it, which would be in the Security log. The command line would show the DLL path.</p>
<p>So, the Sigma rule would have:</p>
<ul>
<li>Logsource: Windows Security</li>
<li>Product: Microsoft Office</li>
<li>Event ID: 4688</li>
<li>Condition looking for the DLL path in the Command Line field, perhaps matching a pattern like "path\to\dll.dll"</li>
</ul>
<p>Then, the detection condition would check if the command line includes the DLL path. The selection would be when the process is associated with an Office application (like Excel.exe, Word.exe, etc.).</p>
<p>But I need to make sure about the exact fields. Let me think of a typical event. The Windows Security log event 4688 (Process Creation) includes fields like NewProcessName, CommandLine, and NewProcessToken. The CommandLine would contain the path to the DLL if Office is loading it. For example, if Word.exe is loading a DLL, the command line might be something like "C:\Program Files\Microsoft Office\Office\addons\mydll.dll".</p>
<p>So the condition would be:</p>
<p>selection | contains(CommandLine, "path\to\dll.dll")</p>
<p>But how to structure this in Sigma. Also, the product in the logsource should be Office, and the category could be process tracking.</p>
<p>Alternatively, if the event is logged in the Application log, with a specific event ID when an Office add-in is loaded. For example, Microsoft Office might have its own event ID for this. But I'm not sure. If I can't confirm, perhaps it's safer to use the Windows Security log.</p>
<p>Another approach: look for processes created by Office apps that load DLLs. So process creation events from Office apps where the command line includes a DLL path.</p>
<p>So the rule would look something like:</p>
<p>logsource:<br />
  category: process_creation<br />
  product: Microsoft Office</p>
<p>detection:<br />
  selection: CommandLine | contains("path\to\dll.dll")</p>
<p>condition: selection</p>
<p>But need to check if there's a better way to detect the actual loading of the DLL. Maybe the DLL is loaded into a process, so the process command line would contain the DLL path. Alternatively, perhaps the DLL path is in a different field.</p>
<p>Alternatively, maybe using the Image field (NewProcessName) and looking for a process name containing a DLL path. But that might not be reliable.</p>
<p>Wait, the CommandLine would contain the actual command line arguments passed to the process. If the DLL is being loaded via the Office app's process, then the command line would include the DLL path. For example, if Office launches a process with the DLL as an argument, the CommandLine would show that.</p>
<p>Therefore, the Sigma rule would check for processes created by Office applications with a CommandLine that contains a DLL path.</p>
<p>So putting it all together, the rule would have:</p>
<p>Logsource: Windows Security<br />
Product: Microsoft Office<br />
Event ID: 4688 (assuming this is the process creation event)<br />
Fields: CommandLine, NewProcessName, etc.</p>
<p>Condition: CommandLine contains the DLL path.</p>
<p>Selection: CommandLine matches the DLL pattern.</p>
<p>Timeframe: Maybe 24 hours.</p>
<p>So the final rule would look like:</p>
<p>logsource:<br />
  category: process_creation<br />
  product: Microsoft Office</p>
<p>detection:<br />
  selection: CommandLine | contains("path\to\dll.dll")<br />
  condition: selection</p>
<p>timeframe: 24h</p>
<p>But wait, the exact path might not be known, so perhaps using a wildcard or regex to find any DLL path. For example, ".*\.dll$"</p>
<p>Alternatively, use the Image field to look for processes named like "dllname.dll" in the NewProcessName field.</p>
<p>Another possibility is that the DLL loading event could be logged in the Windows Application log with a specific event ID when an Office add-in is loaded. If that's the case, then the logsource category would be Application and event ID would be specific to Office.</p>
<p>But without knowing the exact event ID, perhaps using the process creation approach is safer.</p>
<p>Alternatively, maybe the DLL is loaded via a trusted application directory, and the process creation includes that path. For example, if the DLL is in %PROGRAMFILES%\Microsoft Office\Office\addons, then the CommandLine would include that path.</p>
<p>So, the rule would detect when a process is created with a CommandLine containing that path.</p>
<p>Therefore, the Sigma rule would be:</p>
<p>logsource:<br />
  category: process_creation<br />
  product: Windows</p>
<p>detection:<br />
  selection: CommandLine | contains("C:\Program Files\Microsoft Office\Office\addons\*.dll")<br />
  condition: selection</p>
<p>timeframe: 24h</p>
<p>But wait, the product should be Microsoft Office, not Windows. Let me adjust that.</p>
<p>Also, the selection should be more specific. Maybe looking for any DLL loading via Office applications, regardless of the path.</p>
<p>Alternatively, use a regex to find any DLL path in the CommandLine.</p>
<p>Finalizing the rule:</p>
<p>Logsource: Windows Security<br />
Product: Microsoft Office<br />
Event ID: 4688<br />
Fields: CommandLine<br />
Condition: CommandLine contains ".dll"</p>
<p>But how to write the condition correctly in Sigma.</p>
<p>Another example rule from Sigma for DLL loading could be a reference. For example, Sigma rule for DLL search order hijacking:</p>
<p>logsource:<br />
  category: process_creation<br />
  product: Windows</p>
<p>detection:<br />
  selection: CommandLine | contains("rundll32.exe")<br />
  condition: selection</p>
<p>But that's more general.</p>
<p>Applying that logic, the Office DLL loading could be:</p>
<p>logsource:<br />
  category: process_creation<br />
  product: Microsoft Office</p>
<p>detection:<br />
  selection: CommandLine | contains("path\to\dll.dll")<br />
  condition: selection</p>
<p>But since the exact path is not known, perhaps using a regex to match any DLL in the command line.</p>
<p>Alternatively, looking for processes that are DLLs by their name:</p>
<p>selection: Image | ends_with(".dll")</p>
<p>But that would catch any process named with a.dll extension, which might not be malicious.</p>
<p>Hmm. Maybe a better approach is to look for processes created by Office applications that are loading DLLs as part of their command line. So the rule would look for:</p>
<p>Process creation events where:</p>
<ul>
<li>The Image field is an Office application (like excel.exe, word.exe, etc.)</li>
<li>The CommandLine includes a DLL path</li>
</ul>
<p>So the rule would be:</p>
<p>logsource:<br />
  category: process_creation<br />
  product: Microsoft Office</p>
<p>detection:<br />
  selection: CommandLine | contains("path\to\dll.dll")<br />
  condition: Image in ["excel.exe", "word.exe", "powerpnt.exe",...] and selection</p>
<p>But to avoid hardcoding all Office application names, perhaps use a more dynamic approach.</p>
<p>Alternatively, use the Image field to check if it's an Office app. However, process creation events for Office apps might not always have the full path in the Image field (could be just the exe name).</p>
<p>Alternatively, use the NewProcessName field which might have the full path.</p>
<p>So, for example:</p>
<p>selection: NewProcessName | contains("\Office\exe")</p>
<p>But not sure.</p>
<p>Alternatively, the command line might have the DLL path as an argument. For example:</p>
<p>CommandLine: "C:\Program Files\Office\excel.exe" /loadplugin "C:\malware.dll"</p>
<p>In this case, the DLL path is after the /loadplugin argument.</p>
<p>So the condition would be looking for the DLL path in the CommandLine after a known argument or pattern.</p>
<p>But that requires knowing the exact argument used by Office to load DLLs. That's part of the Office runtime behavior.</p>
<p>Alternatively, Office might load DLLs directly via the command line&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0</p>
            </div>
            <div class="item reward-zero" id="group-0-item-4">
                <h4>Content 4</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule for detecting when a.NET Assembly DLL is loaded via an Office application. Let's break this down.</p>
<p>First, I should think about the log sources that could record such events. Office applications might write to Windows Event Logs, especially the Application or System logs. Microsoft Office products often generate events when they load assemblies or plugins.</p>
<p>The key components here are:<br />
1. Office application being used (like Excel, Word, etc.)<br />
2. Loading of a.NET assembly DLL<br />
3. The loading process being initiated by the Office app</p>
<p>I need to identify the specific events that would capture this behavior. Windows events related to COM+ and.NET framework could be relevant here. For example, event IDs like 1000 or 4004 in the Windows Application log might indicate when a.NET assembly is loaded.</p>
<p>The signature should look for events where the application is an Office product, and the event details mention loading an assembly or DLL. The actual event ID might vary based on the Office version and Windows OS, so I should include a generic event ID or use multiple event IDs if possible.</p>
<p>I should also consider the user context. If an admin or regular user is loading a DLL, that's normal. But a malicious actor might use this to load a malicious DLL into an Office app to perform lateral movement or persistence.</p>
<p>The logsource should specify the Windows Event Log category and a generic source name. The detection timeframe should be reasonable, maybe 24 hours.</p>
<p>Putting this all together, the Sigma rule will look for events where the product name is an Office app, the event mentions assembly or DLL loading, and the event ID is in a range that indicates such a loading event.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  selection:<br />
    event.id: (1000 or 4004)<br />
    event.code: (0 or 1)<br />
    product: (Microsoft Office|Microsoft Word|Microsoft Excel|Microsoft PowerPoint|Microsoft Outlook)<br />
  condition: selection and (message contains "Assembly" or message contains "DLL")<br />
logsource:<br />
  category: windows<br />
  product: windows<br />
timeframe: 24h<br />
references:<br />
  - https://docs.microsoft.com/en-us/troubleshoot/windows-client/application-management/event-id-1000<br />
  - https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/event-id-4004<br />
tags:<br />
  - attack.t1014<br />
  - attack.t1190<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-0-item-5">
                <h4>Content 5</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, the user wants a Sigma rule to detect assembly DLLs being loaded via an Office application. Let me think about how to approach this.</p>
<p>First, I need to consider the log sources that would have this information. Office applications typically write event logs when they load external components. So, the log source should be the Windows Event Log, specifically the Application category since Office applications generate events there.</p>
<p>Next, the actual event ID. When an Office app loads an assembly, it generates an event ID 1001 in the Application log. That's a key part of this rule.</p>
<p>The event message will contain details about the DLL being loaded. I should extract specific fields from the message. The DLL path is important, so I'll use the path field. Also, the process name (like excel.exe or word.exe) helps identify which Office app loaded it.</p>
<p>The condition should check for the specific event ID and then look for the occurrence count. Since we want to detect any loading, even a single event might be suspicious, but to be more certain, maybe a count above zero would trigger. Alternatively, checking for the presence of the DLL path in the event message is better.</p>
<p>Putting it all together: the rule needs to select events with ID 1001 in the Application log, where the message contains the DLL path. The detection condition would be that the path is not empty. Then, the logsource should specify the Windows Event Log category.</p>
<p>Timeframe is typically important for detection, so I'll include a 24-hour window. The action part might not be needed since it's an IDS rule, but including something like 'alert' could be useful.</p>
<p>I think that covers the main points. Now, structuring this into the Sigma YAML format.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  selection:<br />
    event.id: 1001<br />
    event.category: application<br />
  condition: event.message | contains("assembly.dll")<br />
logsource:<br />
  category: windows_eventlog<br />
  product: microsoft_office<br />
timeframe: 24h<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-0-item-6">
                <h4>Content 6</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule to detect when an assembly DLL is loaded by an Office application. Let me think through this step by step.</p>
<p>First, what kind of logs would contain information about DLL loading in Office products? Maybe Windows event logs, specifically the Application or System logs. Office applications often use Windows API calls to load DLLs. So I should target Windows event ID 6005, which is the event logged when a DLL is loaded via LoadLibrary.</p>
<p>The event description would include details about the DLL path and the process that loaded it. We need to check if the process name contains an Office product like Excel, Word, Outlook, etc. The DLL path might be a known malicious one, but since the user probably doesn't have that information, we can just look for any unusual DLL loading.</p>
<p>The detection should trigger when an event ID 6005 occurs with a process name that matches any Office product. The logsource should be set to Windows Event Log, with category Application or System, depending on where the events are logged. The timeframe should be reasonable, maybe 24 hours.</p>
<p>Putting it all together, the rule would use the event ID 6005, check the process name for Office applications, and trigger an alert on any such event. I need to make sure the criteria are clear and the fields are properly formatted in the Sigma YAML.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  event_id: 6005<br />
  condition: selection | contains(process, "Office|excel|word|outlook")<br />
  selection: <br />
    process: "*"<br />
  logsource:<br />
    category: windows_event_log<br />
    product: windows<br />
  timeframe: 24h<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-0-item-7">
                <h4>Content 7</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>DotNET Assembly DLL Loaded Via Office Application: Detects any assembly DLL being loaded by an Office Product&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule to detect when a.NET assembly DLL is loaded via an Office application. Let's break this down.</p>
<p>First, the key event here is the loading of a DLL assembly. In Windows, this is typically logged by the Windows Event Log, specifically in the System event log. The event ID for DLL loading is 26, right? So that's the event ID we need to check.</p>
<p>Next, the condition is that the DLL being loaded is a.NET assembly. The DLL name would have a ".dll" extension, but more specifically,.NET assemblies have a ".dll" or ".exe" extension. However, the rule might also include checking for the presence of "System.Reflection.Assembly" or other.NET-related strings in the event details.</p>
<p>Now, the context is important. The loading of this DLL should be triggered by an Office application. So we need to check the process name or the application name in the logs to see if it's an Office product like Excel, Word, PowerPoint, etc. Common ones are Excel.exe, Winword.exe, PowerPoint.exe, etc.</p>
<p>Putting this together, the rule should look for event ID 26 in the System log. The condition should check for the presence of a.NET assembly (like the DLL name or specific.NET-related strings) and that the process name is one of the common Office application executables.</p>
<p>For the logsource, we need to specify the Windows Event Log category. The event code would be 26. The event ID is 26 as well.</p>
<p>The detection condition would combine these elements. We might want to check if the process name is an Office app and if the loaded DLL is a.NET assembly. Alternatively, we can check for the presence of specific keywords in the event description. For example, if the DLL name contains "System.Reflection.Assembly" or similar, or if the process name contains one of the Office executables.</p>
<p>Also, considering the timeframe, maybe 24 hours is enough to catch recent activities. For the selection, we might want to select events where the process name is an Office app and the event details indicate a.NET assembly load.</p>
<p>So, the final rule would have:</p>
<ul>
<li>Logsource: Windows Event Log, category: Windows System, event code: 26, event ID: 26</li>
<li>Detection condition: The process name is an Office app and the loaded DLL is a.NET assembly (could be checked via DLL name or specific strings)</li>
<li>Selection: process contains Office app name and DLL path is a.NET assembly</li>
<li>Timeframe: 24 hours<br />
</think></li>
</ul>
<p>\boxed{<br />
detection:<br />
  condition: selection | contains(process, 'excel|winword|powerpnt|mspub|wordpad|ppdil|eqnpad|onenote') and selection | contains(image, 'System.Reflection.Assembly')<br />
  selection:<br />
    event.code: '26'<br />
    event.id: '26'<br />
    process: <br />
    - excel<br />
    - winword<br />
    - powerpnt<br />
    - mspub<br />
    - wordpad<br />
    - ppdil<br />
    - eqnpad<br />
    - onenote<br />
    image: <br />
      - '<em>System.Reflection.Assembly</em>'<br />
      - '<em>Microsoft.Office.Interop</em>'<br />
detection.condition: selection | contains(process, 'excel|winword|powerpnt|mspub|wordpad|ppdil|eqnpad|onenote') and selection | matches('image|\<em>System\.Reflection\.Assembly\</em>')<br />
logsource:<br />
  category: windows<br />
  product: windows<br />
  service: system<br />
timeframe: 24h<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>

            </div>
        </details>

        <details>
            <summary>Group 1</summary>
            <div class="group-content">
                            <div class="item reward-zero" id="group-1-item-0">
                <h4>Content 0</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule for detecting suspicious Invoke-WebRequest execution. Let's break this down. The key points are:</p>
<ol>
<li>The rule should detect when the Invoke-WebRequest cmdlet is called.</li>
<li>The output is saved in a suspicious location.</li>
<li>The action taken is suspicious, maybe writing to a file with high privilege or in a non-standard path.</li>
</ol>
<p>First, I should check common log sources where PowerShell activity is recorded. Typically, Windows event logs like Security or PowerShell transcript logs are used. </p>
<p>Next, the event ID for PowerShell events. Windows events for PowerShell script execution are usually event ID 4104 in the Windows PowerShell provider logs (Microsoft-Windows-PowerShell/Operational). This event logs when PowerShell scripts are run.</p>
<p>The condition should look for the cmdlet being invoked. So I need to check for the specific cmdlet name in the message field of the event. The message might have "Invoke-WebRequest" or similar strings.</p>
<p>Additionally, the output location is suspicious. Maybe the path contains words like "encrypted", "download", "malware", or is in a non-standard directory like C:\Windows\System32\config. Alternatively, the path might be in a user temp directory but with a long, complex filename.</p>
<p>Also, consider the user context. If this is happening with admin privileges or from a service account that shouldn't be running scripts, that adds to the suspicion.</p>
<p>The event ID for PowerShell execution is 4104. So the logsource should specify Windows event log, category Security, event ID 4104.</p>
<p>The condition will check for the cmdlet name in the message. Maybe using a regex pattern to extract it.</p>
<p>The path should also be part of the condition. Maybe using a regex to check for suspicious paths.</p>
<p>Additionally, the user who executed the command could be part of the condition if it's a privileged account.</p>
<p>Putting it all together:</p>
<p>Logsource is Windows event logs, category Security, event ID 4104.</p>
<p>Condition checks for the cmdlet name in the message and the path in the message.</p>
<p>Selection could be the action of the cmdlet being a suspicious one, like download, upload, or using a privileged path.</p>
<p>Timeframe should be a reasonable period, like 24 hours.</p>
<p>So the final rule would look something like this:</p>
<p>detection:<br />
  condition: selection | within(service, "Invoke-WebRequest") and selection | matches_regex(/Message=".<em>C:\\Windows\\System32\\config\\.</em>"/)</p>
<p>selection:<br />
  service: - Invoke-WebRequest<br />
  action: download<br />
  path: C:\Windows\System32\config\</p>
<p>logsource:<br />
  category: windows_security<br />
  product: windows<br />
  event_id: 4104</p>
<p>timeframe: 24h</p>
<p>I need to make sure the regex is correct for the path and the message. Also, verify that the event ID and logsource parameters are accurate.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | within(service, "Invoke-WebRequest") and selection | matches_regex(/Message=".<em>C:\\Windows\\System32\\config\\.</em>"/)<br />
  selection:<br />
    service: - "Invoke-WebRequest"<br />
    action: download<br />
    path: C:\Windows\System32\config\<br />
logsource:<br />
  category: windows_security<br />
  product: windows<br />
  event_id: 4104<br />
timeframe: 24h<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-1-item-1">
                <h4>Content 1</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, let's see. The user wants a Sigma rule to detect suspicious Invoke-WebRequest execution. They mentioned the command being called and the output going to a suspicious location. Hmm.</p>
<p>First, I need to think about what Invoke-WebRequest does in PowerShell. It's used for making web requests, so someone might be exfiltrating data or contacting an external server. The suspicious part is where the output is saved. Maybe a non-standard path that an attacker would use to hide their activity.</p>
<p>I should structure the rule accordingly. The detection condition would look for the Invoke-WebRequest cmdlet. Then, check the output path. The selection criteria would be when the output is saved to a location like C:\Windows or another common attacker directory. Also, perhaps look for specific arguments like -Uri or -OutFile.</p>
<p>Timeframe should be short, like 24 hours. Log source would be PowerShell. Maybe add some tags like suspicious activity. Need to make sure the syntax is correct for Sigma, using the right fields. Let me put this all together in YAML format.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | cmd_line = "<em>Invoke-WebRequest</em> -OutFile <em>C:\Windows</em>"<br />
  selection:<br />
    cmd_line: "<em>Invoke-WebRequest</em> -OutFile <em>C:\Windows</em>"<br />
  timeframe: 24h<br />
logsource:<br />
  category: powershell<br />
tags:<br />
  - suspicious_activity<br />
  - command_execution<br />
  - lateral_movement<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-1-item-2">
                <h4>Content 2</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, let's tackle this detection rule. The user wants to detect suspicious Invoke-WebRequest execution where the output is in a suspicious location. First, I need to think about what Invoke-WebRequest is commonly used for. It's a legitimate PowerShell cmdlet, but can be misused for things like downloading malicious files or exfiltrating data.</p>
<p>The key points here are:<br />
1. The command itself is Invoke-WebRequest<br />
2. The output (or results) are stored in an unexpected or suspicious location</p>
<p>So the rule should focus on detecting when Invoke-WebRequest is executed and then looking for the output in certain directories. Common suspicious locations could be %Temp%, %AppData%, or maybe something like C:\Windows\System32 or other system directories. But we shouldn't block system directories unless they're definitely not supposed to be modified by user processes.</p>
<p>Additionally, we need to check if the output path is unexpected based on the user's behavior. Maybe if the user doesn't normally write files there, but that's a bit more complex to analyze.</p>
<p>Log sources would typically be PowerShell logs. In Windows environments, Event ID 4104 from the Microsoft-Windows-PowerShell/Operational log is relevant for PowerShell script block logging.</p>
<p>So putting this together, the condition would look for events with PowerShell script block activity and then check if Invoke-WebRequest is being called, and then look for the output being written to a suspicious path.</p>
<p>The timeframe should be short because the attack might be ongoing. Maybe 1 hour or 24 hours? The user didn't specify, but since it's a potential lateral movement attempt, 24 hours might be safer to capture the full context.</p>
<p>Also, the rule needs to specify the log source as the PowerShell operational log. The action type would be "scriptblock_invocation" since we're looking at script block events.</p>
<p>Putting it all together, the rule should have the detection condition checking the script block content for Invoke-WebRequest and its output path. If both conditions are met, it's a match.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  selection:<br />
    event.type: "ScriptBlockInvocation"<br />
    event.scriptblock.content:<br />
      - Invoke-WebRequest<br />
      - -Uri (output_path)<br />
  condition: selection and output_path not in ["C:\Windows\Temp<em>", "C:\Users\</em><em>\AppData\Local\Temp</em>"]<br />
logsource:<br />
  category: windows_event_log<br />
  product: windows<br />
  service: microsoft-windows-powershell<br />
timeframe: 24h<br />
tags:<br />
  - suspicious_powershell<br />
  - lateral_movement<br />
  - command_execution<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-1-item-3">
                <h4>Content 3</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, let's see. The user wants a Sigma rule to detect suspicious use of Invoke-WebRequest. The key points here are that the command is being used and the output is in a suspicious location. I need to think about how PowerShell logs work. </p>
<p>First, I should check the event ID for PowerShell events. I recall that PowerShell script blocks are logged with ID 4104. So the rule should reference that. The command line should include "Invoke-WebRequest" and probably some suspicious arguments. The output location is important here. Maybe the output is saved in a temporary folder, or to a network share. </p>
<p>The user mentioned the output is in a suspicious location. So I need to look for paths like %TEMP%, a network path, or a directory that shouldn't be used for web requests. Also, maybe checking for certain URLs being accessed that are unusual. </p>
<p>So the condition would be looking for event ID 4104 with the command containing "Invoke-WebRequest". Then, the output path needs to be checked. The selection would filter for paths that match certain patterns. The action would be to flag if the output path is in a known suspicious location. </p>
<p>I should also add a timeframe of 24 hours. Logsource would be Windows PowerShell. That should cover the main elements. Let me structure this step by step.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  description: Detects suspicious Invoke-WebRequest execution with output to a known suspicious location<br />
  logsource:<br />
    category: windows_event_logs<br />
    product: windows<br />
    service: Microsoft-Windows-PowerShell/Operational<br />
  selection:<br />
    event.id: 4104<br />
    command: Invoke-WebRequest<br />
  condition: selection and output_path matches within ('%TEMP%', '\\*\', '\*\', 'C:\Windows\Temp*')<br />
  level: info<br />
  timeframe: 24h<br />
  references:<br />
    - https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/win_susp_command_line.yml<br />
  tags:<br />
    - suspicious<br />
    - lateral_movement<br />
    - privilege_escalation<br />
}</p>
<p>This rule detects suspicious Invoke-WebRequest executions by checking for known suspicious output paths, such as %TEMP% or network paths, and flags events where the command line includes Invoke-WebRequest.&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0</p>
            </div>
            <div class="item reward-zero" id="group-1-item-4">
                <h4>Content 4</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule for detecting suspicious Invoke-WebRequest execution. Let's break this down. The key points mentioned are:</p>
<ol>
<li>The command is Invoke-WebRequest</li>
<li>The output is saved to a suspicious location</li>
</ol>
<p>First, I need to think about the event logs in Windows that would capture PowerShell execution. Typically, PowerShell commands are logged in the Windows PowerShell module of the Windows event logs.</p>
<p>The Invoke-WebRequest cmdlet is part of PowerShell. When it's executed, depending on the version of PowerShell, the execution might be logged in an event ID. I recall that in some environments, PowerShell commands are logged with event ID 4104 when executed from a command line. Also, when PowerShell is used to run commands, especially ones that might be suspicious, the event ID might vary based on the execution context.</p>
<p>The output being saved to a suspicious location is important. So, we need to check the log for where the output is being stored. If it's a location that's not typically used by normal applications, like system32 directories, temporary directories, or other unexpected places, that could be a red flag.</p>
<p>So, the rule should look for events where PowerShell is executing an Invoke-WebRequest command and check the output path. The condition would be something like the command line containing "Invoke-WebRequest" and the output path being in a suspicious directory.</p>
<p>Also, considering the timeframe. Since this might be part of an attack, a short timeframe like 24 hours might be appropriate.</p>
<p>Putting this all together, the Sigma rule would look for an event where:</p>
<ul>
<li>The command line includes "Invoke-WebRequest"</li>
<li>The output path is in a suspicious location</li>
<li>The event ID is from the PowerShell execution log</li>
</ul>
<p>Additionally, setting the logsource to the appropriate Windows event log category (like Windows PowerShell), and specifying the action as the execution of the cmdlet.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  selection:<br />
    event_id: 4104<br />
    command_line: "<em> Invoke-WebRequest </em>"<br />
    field: CommandLine<br />
    condition: "CommandLine | contains('Invoke-WebRequest')"<br />
    output: "CommandLine | contains('Out-File') | extract_output_path"<br />
  condition: "output | contains('C:\Windows\System32') or output | contains('C:\inetpub') or output | contains('C:\Program Files')"<br />
  timeframe: 24h<br />
logsource:<br />
  category: windows_eventlog<br />
  product: windows<br />
  service: powershell<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-1-item-5">
                <h4>Content 5</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule to detect suspicious Invoke-WebRequest execution. Let's start by understanding the scenario. Invoke-WebRequest is a legitimate PowerShell cmdlet used for making HTTP requests, but it can be misused for exfiltrating data or connecting to malicious endpoints.</p>
<p>The user mentioned that the and output is located in a suspicious location. Wait, the original message seems incomplete. Let me check again. Oh, it says "and output is located in a suspicious location". Maybe there was a typo or part of the message missing. But based on what's there, I need to think about what makes the Invoke-WebRequest suspicious.</p>
<p>Typically, Invoke-WebRequest might be flagged if it's used in a script or command that's part of a known malicious payload. The suspicious location could refer to the output file being saved in a non-standard directory, like a user's Documents folder or a temp location. Alternatively, the output might be sent to a remote endpoint, which would be a red flag.</p>
<p>So the conditions for detection could be:<br />
1. The cmdlet is called with certain parameters<br />
2. The output is saved to a non-standard or unexpected location<br />
3. The output is sent to a known malicious IP or domain</p>
<p>I need to structure this into a Sigma rule. The detection.condition would capture the cmdlet usage. The selection could filter based on parameters or file paths. The logsource would specify Windows event logs, maybe PowerShell or process monitoring.</p>
<p>Wait, the original message mentions "and output is located in a suspicious location". Maybe that's a typo and should be "the output is located in a suspicious location". Assuming that, the key is where the output is saved. So, for example, if Invoke-WebRequest saves output to %userprofile%\Documents\output.txt, that's unusual.</p>
<p>I should also consider the parameters used. For example, if it's saving output to a remote location or using certain HTTP methods that are uncommon for legitimate use.</p>
<p>So putting this together, the rule would check for PowerShell commands that execute Invoke-WebRequest with suspicious parameters or output paths. The selection would filter for certain parameters or file paths. The condition would aggregate these elements.</p>
<p>I need to structure the rule using the correct Sigma fields. The logsource should specify the platform (Windows), category (process creation, maybe), and the event IDs. The detection.condition would use a custom query based on the parameters and file paths. The selection would set conditions on those parameters or paths.</p>
<p>I should also check for common patterns, such as saving output to %systemdrive%\Windows\Temp or similar, which might be an attempt to exfiltrate data. Or using the -OutFile parameter to a location that's not expected.</p>
<p>Also, if the output is redirected to a remote server, that's another red flag. So looking for Invoke-WebRequest with the -Uri parameter pointing to a suspicious domain or IP.</p>
<p>Putting it all together, the Sigma rule would have a condition that checks for the cmdlet and suspicious parameters, with the selection filtering those parameters. The logsource would be Windows, probably the Powershell event logs.</p>
<p>I need to make sure the rule is specific enough to catch suspicious use cases but not too broad to generate false positives. Maybe also check for the count of Invoke-WebRequest calls in a short timeframe.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(cmdline) by user where cmdline contains "Invoke-WebRequest" and (cmdline contains "-OutFile" and cmdline contains "C:\Windows\Temp\") or cmdline contains "http://baddomain.com"<br />
  selection:<br />
    cmdline:<br />
      - "<em> -OutFile C:\Windows\Temp\</em>"<br />
      - "<em> http://baddomain.com/</em>"<br />
    user:<br />
      - "*"<br />
  logsource:<br />
    category: process_creation<br />
    product: windows<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>
            <div class="item reward-zero" id="group-1-item-6">
                <h4>Content 6</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, I need to create a Sigma rule for detecting suspicious Invoke-WebRequest execution. The user mentioned that the cmdlet is called and the output is in a suspicious location. Let's break this down.</p>
<p>First, I should consider the typical logs that would capture PowerShell usage. Windows Event Logs, specifically PowerShell, would be the primary source. The event ID for PowerShell execution is 4104, so that's a key part of the logsource.</p>
<p>Next, the condition: detecting when Invoke-WebRequest is called. In PowerShell, the command name would be visible in the event log. So I should look for the command line that includes "Invoke-WebRequest" as the command.</p>
<p>Then, the suspicious output location. The user mentioned the output is in a certain location. I need to think about what makes a location suspicious. Common places PowerShell outputs temporary files or scripts could be %temp%, %systemdrive%, or maybe even network shares. But the user might not specify the exact location. Since the original description just says "suspicious location," I'll need to make an assumption here. Maybe looking for output to a directory that's not typical, like C:\Program Files or a share. Alternatively, perhaps the output path contains certain keywords like "temp", "downloads", etc. But since the user didn't specify, I'll need to be cautious here. Maybe the command includes a specific path that's known to be suspicious.</p>
<p>So the condition would involve checking if the command line includes "Invoke-WebRequest" and if the output path is in a known suspicious location. Alternatively, if the output path is not a standard system directory. But how to represent that in a Sigma rule?</p>
<p>In the selection part, I can filter for events where the command line contains "Invoke-WebRequest" and the output path is in a certain directory. But since the user wants to detect when output is in a suspicious location, maybe we need to specify a list of such directories. However, without specific guidance, perhaps using a regular expression to detect paths that are not system directories. For example, paths that include spaces, network paths, or specific keywords like "system32", "C:\Windows", etc. But again, this is speculative.</p>
<p>Alternatively, the output location could be a network share, which is common in lateral movement. So checking if the output path starts with a network path like "\server\share\".</p>
<p>Putting this together, the rule would check for PowerShell events where the command is Invoke-WebRequest and the output path is a network share or a suspicious local path. The selection part would filter for events where the command line includes Invoke-WebRequest, the executable is PowerShell.exe, and the output path is in a known suspicious location.</p>
<p>I need to structure this in Sigma's YAML format. The logsource would be Windows Event Log, category PowerShell. The selection would use a where clause to filter the events based on command line and output path. The condition would combine these filters.</p>
<p>Wait, the user mentioned the output is located in a suspicious location. But in PowerShell, when using Invoke-WebRequest, the output would typically be the returned data from the web request. So maybe the output is being saved to a file, which is then written to a suspicious location. But how is that captured in the event logs? The PowerShell events don't log the file writes, only the command execution. So perhaps the rule is based on the command line parameters. If Invoke-WebRequest is used with a -OutFile parameter pointing to a suspicious location, that's the trigger.</p>
<p>So the condition would be when the command line includes "-OutFile" followed by a path. The suspicious path would be detected by checking if the path is in a known bad directory. Alternatively, if the path is a network path.</p>
<p>Therefore, the Sigma rule would look for PowerShell events where the command line contains "Invoke-WebRequest" and "-OutFile" parameters with paths that match certain patterns indicating a suspicious output location.</p>
<p>So putting it all together:</p>
<p>logsource:<br />
  category: windows_event_log<br />
  product: windows<br />
  event_id: 4104</p>
<p>selection:<br />
  command_line: "<em>Invoke-WebRequest</em> -OutFile *"</p>
<p>The condition would be that this selection is true. The output path is the parameter passed to -OutFile. If that path is in a suspicious location, then the condition is met.</p>
<p>But how to specify the suspicious location? Maybe using a regular expression or a list of paths. However, without specific guidance from the user, perhaps the best approach is to use a whitelist of known good paths and trigger on any path not in that list. But that's more complex.</p>
<p>Alternatively, looking for paths that are not in standard system directories. For example, paths that include spaces, network paths, or specific keywords like "temp", "downloads", etc.</p>
<p>Alternatively, if the user just wants to detect when Invoke-WebRequest is used with an -OutFile parameter to a location that's not the user's local profile directory, temp, or downloads, then we can specify those directories in a blacklist and trigger when the path is outside those directories.</p>
<p>But without specific details from the user, maybe it's better to detect when Invoke-WebRequest is used with -OutFile parameter to a network path. That's a common indicator of malicious activity.</p>
<p>So the rule would be:</p>
<p>detection:<br />
  condition: selection | count(param) by cmd_line &gt; 1 and param == "-OutFile"</p>
<p>selection:<br />
  param: "-OutFile"<br />
  value: "\"  # looking for network paths starting with double backslashes</p>
<p>But maybe a more precise approach is to check if the output file path starts with a network share, which is often a sign of lateral movement.</p>
<p>Alternatively, check if the path contains certain characters like spaces or specific patterns.</p>
<p>But since the user's original description said "output is located in a suspicious location," perhaps the rule should trigger when the -OutFile parameter points to a non-standard location. But how to define that?</p>
<p>Another approach is to check if the path is not in the user's profile directory or temp directory. For example, the user's temp directory is usually something like C:\Users\<username>\AppData\Local\Temp. So if the -OutFile parameter points to a different location, it's suspicious.</p>
<p>So the selection could be:</p>
<p>param: "-OutFile"<br />
  value: "<em>C:\Program Files</em>"<br />
  operator: not</p>
<p>But again, without specific details, it's challenging.</p>
<p>Alternatively, the rule can be written to trigger when the Invoke-WebRequest command is used with output to a directory that's not the user's profile or temp directory. But how to represent that.</p>
<p>Alternatively, the rule can check for the -OutFile parameter and trigger if the path is not in a list of allowed directories. But that requires a list of allowed directories.</p>
<p>However, given the lack of specific information, perhaps the best way is to detect when Invoke-WebRequest is used with an -OutFile parameter pointing to a network path. This is a common indicator of malicious activity.</p>
<p>So the Sigma rule would be:</p>
<p>detection:<br />
  condition: selection | count(param) by cmd_line &gt; 1 and param == "-OutFile"</p>
<p>selection:<br />
  param: "-OutFile"<br />
  value: "\"<br />
  operator: starts_with</p>
<p>logsource:<br />
  category: windows_event_log<br />
  product: windows<br />
  event_id: 4104</p>
<p>But maybe more precisely, the path should start with "\". So the selection could be:</p>
<p>param: "-OutFile"<br />
  value: "\\"<br />
  operator: starts_with</p>
<p>But perhaps that's too specific.</p>
<p>Alternatively, using a regex to match any path that starts with a network share:</p>
<p>param: "-OutFile"<br />
  value: "^\\"<br />
  operator: regex</p>
<p>But I'm not sure about the exact syntax. In Sigma, the values can be regex, but the exact syntax depends on the backend. The Sigma documentation specifies that you can use regex in the value field.</p>
<p>So combining all this, the rule would look for PowerShell events where the command line includes "Invoke-WebRequest" and "-OutFile" with a path that starts with a network share. This is a common way for attackers to exfiltrate data or drop files to a share for further access.</p>
<p>Thus, the final rule would be:</p>
<p>detection:<br />
  condition: selection | count(param) by cmd_line &gt; 1 and param == "-OutFile" and (<br />
      param_value | regex "^\\"<br />
  )</p>
<p>selection:<br />
  command_line: "<em>Invoke-WebRequest</em>"<br />
  param: "-OutFile"<br />
  param_value: "$('param').value"</p>
<p>logsource:<br />
  category: windows_event_log<br />
  product: windows<br />
  service: powershell<br />
  event_type: script_block_log</p>
<p>But wait, the event type in Sigma for PowerShell is typically script_block_log. Also, the event ID is 4104 for PowerShell script blocks.</p>
<p>So adjusting the logsource:</p>
<p>logsource:<br />
  category: windows_event_log<br />
  product: windows<br />
  service: powershell<br />
  event_type: script_block_log</p>
<p>Also, the condition should correctly combine the selection parameters. The original selection is a list of parameters. So the condition would be:</p>
<p>selection: command_line contains "Invoke-WebRequest" and param "-OutFile" and param_value starts with "\"</p>
<p>But the Sigma syntax for the selection is a bit different. Each condition is "param: value, operator". So using a where clause to combine these.</p>
<p>Alternatively, the selection can be structured as:</p>
<p>selection:<br />
  command_line: "<em>Invoke-WebRequest</em>"<br />
  and:<br />
    - param: "-OutFile"<br />
      value: "\"<br />
      operator: starts_with</p>
<p>But in Sigma, the selection is structured as a list of conditions that are combined with AND. So each condition is an object with param, operator, and value.</p>
<p>Putting it all together, the rule would be:</p>
<p>detection:<br />
  condition: selection | count(param) by cmd_line &gt; 1</p>
<p>selection:<br />
  command_line: "<em>Invoke-WebRequest</em>&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0</p>
            </div>
            <div class="item reward-zero" id="group-1-item-7">
                <h4>Content 7</h4>
                <div class="content-block">
                    <p>&lt;|begin_of_text|&gt;&lt;|start_header_id|&gt;system&lt;|end_header_id|&gt;</p>
<p>You are a systematic, deep-reasoning AI trained to solve detection engineering problems by constructing Sigma rules. You must first <strong>think carefully</strong> through the problem using structured internal monologue enclosed in <think>...</think> tags, and then provide your final Sigma rule as a YAML block enclosed in a LaTeX \boxed{...} environment.</p>
<p><strong>You MUST follow this exact output format:</strong><br />
<think><br />
Step-by-step reasoning, outlining how you arrived at the rule. Include relevant knowledge about Sigma syntax, threat detection context, and how you chose each field.<br />
</think></p>
<p>\boxed{<br />
<YAML Sigma Rule><br />
}</p>
<p><strong>Important Rules:</strong><br />
- DO NOT skip the <think> tags — all your thoughts must be inside them.<br />
- DO NOT skip the \boxed{...} wrapper — your final YAML answer MUST go inside it.<br />
- DO NOT output anything outside the <think> and \boxed{} blocks.<br />
- The content inside \boxed{} must be <strong>pure YAML</strong>, with <strong>no extra formatting characters</strong> (no bullets, backticks, emojis, or markdown) so it can be passed <strong>directly</strong> to <code>yaml.safe_load()</code>.<br />
- You are allocated a maximum of 2048 tokens — be detailed but concise.<br />
- Your final output must be valid YAML for a Sigma rule, with correct indentation and field names.<br />
- Use Sigma best practices: include <code>detection.condition</code>, <code>detection.selection</code>, <code>logsource</code>, and <code>timeframe</code> when appropriate.<br />
- Match the format and style of this example:</p>
<p>Example:<br />
<think><br />
This rule is intended to detect potential lateral movement attempts by monitoring for excessive outbound connections. The condition'selection | count(dst_ip) by src_ip &gt; 10' flags when one source IP connects to more than 10 destination IPs. The log source is firewall logs, and the action is 'denied'.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection | count(dst_ip) by src_ip &gt; 10<br />
  selection:<br />
    action: denied<br />
  timeframe: 24h<br />
logsource:<br />
  category: firewall<br />
}</p>
<p>Only produce answers in this format. Think first, then answer clearly in YAML. Follow YAML syntax exactly.&lt;|eot_id|&gt;&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</p>
<p>Suspicious Invoke-WebRequest Execution: Detects a suspicious call to Invoke-WebRequest cmdlet where the and output is located in a suspicious location&lt;|eot_id|&gt;&lt;|start_header_id|&gt;assistant&lt;|end_header_id|&gt;</p>
<p><think><br />
Okay, let's break this down. The user wants a Sigma rule to detect suspicious use of Invoke-WebRequest. The key points are that the call to Invoke-WebRequest is happening, and the output is going to a suspicious location. </p>
<p>First, I need to determine the Windows event IDs that log PowerShell execution. Typically, PowerShell script block logging or creating a process are the main ones. For script block logging, the event ID is 4104. When a process is created via PowerShell, it's event ID 4688, but that's not specific to PowerShell commands.</p>
<p>So, the core condition is looking for an event ID 4104, which logs PowerShell script block execution. The command being executed should contain 'Invoke-WebRequest'. Then, I need to check the target path where the output is stored. Since the output location is suspicious, I should filter for paths that match a known pattern, like C:\Temp or C:\Windows\Temp. </p>
<p>The detection condition would involve checking if the PowerShell script block contains the command and if the output path is in a restricted directory. The selection might be the event ID and specific fields like the command and target path. </p>
<p>For the timeframe, since this is likely a targeted attack, maybe 72 hours would be appropriate. The logsource would be set to Windows PowerShell. The action field should specify what to do when this rule triggers, like alert or log.</p>
<p>Wait, the user also mentioned the output location. So I need to check the 'OutputData' field in the event. If that path is in a suspicious location, like %TEMP% or %SYSTEMROOT%\Temp, then that's a red flag. So in the detection condition, I should check if 'OutputData' contains a path that matches a known suspicious directory pattern.</p>
<p>Putting it all together, the rule would look for event ID 4104 where the script contains 'Invoke-WebRequest' and the output path is in a restricted directory. The selection would include the command and target path. Timeframe is 72 hours. Logsource is Windows PowerShell. The action could be to alert or block.<br />
</think></p>
<p>\boxed{<br />
detection:<br />
  condition: selection where event.id == 4104 and ScriptBlockText contains "Invoke-WebRequest" and OutputData matches ".<em>C:\\Temp.</em>" or ".<em>C:\\Windows\\Temp.</em>"<br />
  selection:<br />
    event.type: "powershell_script_block"<br />
    command: "Invoke-WebRequest"<br />
    output_path: OutputData<br />
  timeframe: 72h<br />
logsource:<br />
  category: microsoft_windows_powershell<br />
  product: windows<br />
}&lt;|eot_id|&gt;</p>
                </div>
                <p><strong>Reward:</strong> 0.0</p>
            </div>

            </div>
        </details>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const items = document.querySelectorAll('.item');
            let activeIndex = -1; // No item active initially

            // Function to set active item
            function setActiveItem(index) {
                if (activeIndex >= 0 && activeIndex < items.length) {
                    items[activeIndex].classList.remove('active');
                    items[activeIndex].removeAttribute('tabindex'); // Remove from tab order when not active
                }
                if (index >= 0 && index < items.length) {
                    items[index].classList.add('active');
                    items[index].setAttribute('tabindex', '0'); // Make active item focusable
                    items[index].focus(); // Focus the element
                    // Ensure the parent <details> is open
                    const detailsParent = items[index].closest('details');
                    if (detailsParent && !detailsParent.open) {
                        detailsParent.open = true;
                    }
                    // Scroll into view with options if needed (focus should handle this mostly)
                    // items[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    activeIndex = index;
                } else {
                    activeIndex = -1; // Deactivate if index is out of bounds
                }
            }

            // Add click listener to activate items
            items.forEach((item, index) => {
                item.addEventListener('click', () => {
                    setActiveItem(index);
                });
                // Make items focusable initially only if we want tab navigation
                // item.setAttribute('tabindex', '0');
            });

            // Add keydown listener for arrow navigation
            document.addEventListener('keydown', (event) => {
                let targetIndex = -1;
                if (event.key === 'ArrowDown') {
                    event.preventDefault(); // Prevent default page scroll
                    targetIndex = (activeIndex === -1) ? 0 : Math.min(activeIndex + 1, items.length - 1);
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault(); // Prevent default page scroll
                    targetIndex = (activeIndex === -1) ? items.length - 1 : Math.max(activeIndex - 1, 0);
                }

                if (targetIndex !== -1) {
                    setActiveItem(targetIndex);
                }
            });

            // Make first item focusable initially if you want immediate keyboard nav
             if (items.length > 0) {
                 // items[0].setAttribute('tabindex', '0');
                 // Optionally activate the first item on load:
                 // setActiveItem(0);
             }
        });
    </script>
</body>
</html>
